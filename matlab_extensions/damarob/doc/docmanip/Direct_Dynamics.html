
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>Direct_Dynamics</title>
      <meta name="generator" content="MATLAB 7.4">
      <meta name="date" content="2009-11-24">
      <meta name="m-file" content="Direct_Dynamics"><style>

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head>
   <body>
      <div class="content">
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#2">check data</a></li>
               <li><a href="#3">Some initializations</a></li>
               <li><a href="#4">Jacobian matrices of center of masses</a></li>
               <li><a href="#5">Jacobian matrices of motors</a></li>
               <li><a href="#6">Rotor's rotation matrices</a></li>
               <li><a href="#7">Dynamics Matrices</a></li>
            </ul>
         </div><pre class="codeinput"><span class="keyword">function</span> Direct_Dynamics(manip)

<span class="comment">% DIRECT_DYNAMICS evaluates direct dynamics of a manipulator object</span>
<span class="comment">%    syntax: manip.Direct_Dynamics</span>
<span class="comment">%</span>
<span class="comment">%  Evaluates: dynamic matrices B C g</span>
<span class="comment">%             Jacobian matrices related to rotors' and joints' COM position</span>
<span class="comment">%             and stores them into manipulator as follows:</span>
<span class="comment">%</span>
<span class="comment">%     manip</span>
<span class="comment">%       |</span>
<span class="comment">%       +--dyn</span>
<span class="comment">%       |   +--B: manipulator inertia matrix</span>
<span class="comment">%       |   +--C: Coriolis and centripetal matrix (christoffeln)</span>
<span class="comment">%       |   +--g: gravity coloumn vector</span>
<span class="comment">%       |</span>
<span class="comment">%       +--kin</span>
<span class="comment">%       |   +-- Jp_l{1}..Jp_l{n}: geometric Jacobian matrix related to joints' COM position</span>
<span class="comment">%       |   +-- Jo_l{1}..Jo_l{n}: geometric Jacobian matrix related to joints' COM orientation</span>
<span class="comment">%       |   +-- Jp_m{1}..Jp_m{n}: geometric Jacobian matrix related to rotors' COM position</span>
<span class="comment">%       |   +-- Jo_m{1}..Jo_m{n}: geometric Jacobian matrix related to rotors' COM orientation</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%    needs:</span>
<span class="comment">%       * direct kinematics evaluation through Direct_Kinematics.</span>
<span class="comment">%       * a correct set of dynamic data (masses, inertia tensors ...)</span>
<span class="comment">%         inserted through InsertDyndata,</span>
<span class="comment">%</span>
<span class="comment">%    note : COM stands for 'center of mass'</span>
<span class="comment">%</span>
<span class="comment">%     See also manipulator</span>
<span class="comment">%              manipulator/InsertDyndata</span>
<span class="comment">%              manipulator/Direct_Kinematics</span>
<span class="comment">%</span>
<span class="comment">% Copyright (C) 2009, by Carmine Dario Bellicoso and Marco Caputano.</span>
<span class="comment">% This file is part of GNU LGPLv2.1 DAMA^{ROB}</span>
<span class="comment">%    http://www.damarob.altervista.org</span>
<span class="comment">%</span>
</pre><h2>check data<a name="2"></a></h2><pre class="codeinput"><span class="keyword">if</span> isempty(manip.dyndata) || manip.dyndata ~= 1
    NL = [char(13),char(10)]; <span class="comment">% 'new line' string</span>
    disp([<span class="string">'Dynamic Data not inserted correctly, see manipulator.dyndata '</span>,NL,<span class="string">'Direct_Dynamics aborted.'</span>,NL]);
    <span class="keyword">return</span>
<span class="keyword">end</span>

<span class="keyword">if</span> manip.DH.r == 0
    manip.display;
    <span class="keyword">return</span>
<span class="keyword">end</span>

<span class="keyword">if</span> manip.evaluated.Direct_Dynamics == 1
    NL = [char(13),char(10)]; <span class="comment">% 'new line' string</span>
    disp([<span class="string">'Direct Dynamics already evaluated '</span>,NL,<span class="string">'Direct_Dynamics aborted.'</span>,NL]);
    <span class="keyword">return</span>
<span class="keyword">end</span>

<span class="keyword">if</span> manip.evaluated.Direct_Kinematics == 0
    NL = [char(13),char(10)]; <span class="comment">% 'new line' string</span>
    disp([<span class="string">'Direct Kinematics not evaluated '</span>,NL,<span class="string">'Please run Direct_Kinematics first.'</span>,NL]);
    <span class="keyword">return</span>
<span class="keyword">end</span>
</pre><h2>Some initializations<a name="3"></a></h2><pre class="codeinput">g0 = manip.dyn.data.g0(:);
r = manip.DH.r;
DH = cell(1,r);
Jp_l = cell(1,r);
Jo_l = cell(1,r);
Jp_m = cell(1,r);
A = cell(1,r);
R = cell(1,r);
Rm = cell(1,r);
B = sym(zeros(r,r));
C = sym(zeros(r,r));
chr = sym(zeros(r,r,r));
g = sym(zeros(r,1));
<span class="comment">% T = cell(1,r);</span>

pl = manip.dyn.data.pl;
pm = manip.dyn.data.pm;
kr = manip.dyn.data.kr;
ml = manip.dyn.data.ml;
mm = manip.dyn.data.mm;
I_l = manip.dyn.data.Il;
I_m = manip.dyn.data.Im;
zm = manip.dyn.data.zm;

<span class="comment">% coloumn vectors</span>
<span class="keyword">for</span> i=1:r
    pl{i} =  pl{i}(:);
    pm{i} =  pm{i}(:);
    zm{i} =  zm{i}(:);
<span class="keyword">end</span>

<span class="comment">% store manipulator's data into cell arrays</span>
<span class="keyword">for</span> i=1:r
    R{i} = manip.kin.R.R{i}; <span class="comment">%R{i} = R_i</span>
    <span class="comment">%    T{i} = manip.kin.T.T{i}; %T{i} = T_i</span>
    A{i} = manip.kin.A.A{i}; <span class="comment">%A{i} = A_i</span>
    <span class="comment">% note that A_i is the homogeneous transformation matrix between frames i and i-i</span>
<span class="keyword">end</span>
</pre><h2>Jacobian matrices of center of masses<a name="4"></a></h2><pre class="codeinput">disp(<span class="string">'Evaluating jacobian matrices of center of masses ...'</span>);
<span class="keyword">for</span> i=1:r
    DH{i} = manip.DH.table(1:i , :);    <span class="comment">%firsts 'i' rows of DH table</span>
    <span class="keyword">if</span> DH{i}(i,5) == 0 <span class="comment">% revolute joint</span>
        DH{i}(i,1) = DH{i}(i,1) + [1 0 0]*pl{i};  <span class="comment">% adds pl_i|x to a(i)</span>
    <span class="keyword">else</span>               <span class="comment">% prismatic joint</span>
        DH{i}(i,3) = [0 0 1 0] * A{i}*[pl{i};1];  <span class="comment">%adds (l_i^(i-1))_z to d(i)</span>
    <span class="keyword">end</span>

    robtemp = manipulator([DH{i}(:,1),DH{i}(:,2),DH{i}(:,3),DH{i}(:,4),DH{i}(:,5)],<span class="string">'tmp'</span>);
    robtemp.Direct_Kinematics;

    Jli = [robtemp.kin.J.J zeros(6,r-i)];
    Jp_l{i} = Jli(1:3,:);
    Jo_l{i} = Jli(4:6,:);
    robtemp.delete;
<span class="keyword">end</span>


<span class="comment">% (store)</span>
manip.kin.J.Jp_l=Jp_l;
manip.kin.J.Jo_l=Jo_l;
</pre><h2>Jacobian matrices of motors<a name="5"></a></h2><pre class="codeinput">disp(<span class="string">'Evaluating jacobian matrices of motors ...'</span>);
<span class="comment">% Orientation</span>
Jo_m = Jo_l;
<span class="keyword">for</span> i=1:r
    Jo_m{i}(:,i) = kr(i)*zm{i};
<span class="keyword">end</span>

Jp_m{1} = 0*Jp_l{1}; <span class="comment">% init</span>
<span class="comment">% Position</span>
<span class="keyword">for</span> i=1:r-1
    DH{i} = manip.DH.table(1:i , :);    <span class="comment">%firsts 'i' rows of DH table</span>
    <span class="keyword">if</span> DH{i}(i,5) == 0 <span class="comment">% revolute joint</span>
        DH{i}(i,1) = DH{i}(i,1) + [1 0 0]*pm{i+1};  <span class="comment">% adds pm_(i+1)|x to a(i)</span>
    <span class="keyword">else</span>               <span class="comment">% prismatic joint</span>
        <span class="comment">%adds (pm_(i+1)^(i-1))_z to d(i)</span>
        DH{i}(i,3) = [0 0 1 0] * A{i}*[pm{i+1};0];
    <span class="keyword">end</span>

    <span class="comment">%     robtemp = Denavit_Hartenberg_Table(DH{i}(:,1).', ...</span>
    <span class="comment">%         DH{i}(:,2).',DH{i}(:,3).',DH{i}(:,4).',DH{i}(:,5).');</span>
    <span class="comment">%     robtemp = Direct_Kinematics(robtemp);</span>
    robtemp = manipulator([DH{i}(:,1),DH{i}(:,2),DH{i}(:,3),DH{i}(:,4),DH{i}(:,5)],<span class="string">'tmp'</span>);
    robtemp.Direct_Kinematics;

    Jmip1 = [robtemp.kin.J.J zeros(6,r-i)];
    Jp_m{i+1} = Jmip1(1:3,:);
    robtemp.delete;
<span class="keyword">end</span>


<span class="comment">% (store)</span>
manip.kin.J.Jp_m=Jp_m;
manip.kin.J.Jo_m=Jo_m;
</pre><h2>Rotor's rotation matrices<a name="6"></a></h2><pre class="codeinput">disp(<span class="string">'Evaluating rotor''s rotation matrices ...'</span>);
<span class="comment">%   Rm matrices will be:</span>
<span class="comment">% [ 0 0  | ]</span>
<span class="comment">% [ 0 0 zm ]</span>
<span class="comment">% [ 0 0  | ]</span>
<span class="comment">% where first two columns will be two vectors orthonormal to zm</span>

<span class="keyword">for</span> i=1:r
    zmi = R{i}*zm{i} / norm(zm{i});      <span class="comment">% zmi in 0-frame, normalized</span>
    ymi = cross(zmi,rand(3,1));  <span class="comment">% pseudorandom vector, perpendicular to zm</span>
    norm_ymi = (ymi.'*ymi)^(1/2);
    ymi = ymi/norm_ymi;                        <span class="comment">% ymi orthonormal to zm</span>
    xmi = cross(ymi,zmi);                        <span class="comment">% xmi</span>
    Rm{i} = [xmi, ymi, zmi];
<span class="keyword">end</span>
</pre><h2>Dynamics Matrices<a name="7"></a></h2><pre class="codeinput">disp(<span class="string">'Evaluating dynamics matrices ...'</span>);
<span class="comment">% B</span>
<span class="keyword">for</span> i=1:r
    B = B + ml(i) * (Jp_l{i}.' * Jp_l{i}) + <span class="keyword">...</span>
        (Jo_l{i}.' *R{i} *I_l{i} *R{i}.'  * Jo_l{i}) + <span class="keyword">...</span>
        mm(i) * Jp_m{i}.' * Jp_m{i} + <span class="keyword">...</span>
        (Jo_m{i}.' *Rm{i} *I_m{i} *Rm{i}.'  * Jo_m{i}) ;
<span class="keyword">end</span>
disp (<span class="string">'  B'</span>);

<span class="comment">% christoffel's signs (C)</span>
<span class="keyword">for</span> i=1:r
    <span class="keyword">for</span> j=1:r
        <span class="keyword">for</span> k=1:r
            chr(i,j,k) = 1/2* ( diff(B(i,j), manip.jointvar.q(k)) + <span class="keyword">...</span>
                diff(B(i,k), manip.jointvar.q(j)) - <span class="keyword">...</span>
                diff(B(j,k), manip.jointvar.q(i)));
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% C</span>
<span class="keyword">for</span> i=1:r
    <span class="keyword">for</span> j=1:r
        <span class="keyword">for</span> k=1:r
            C(i,j) = C(i,j) + chr(i,j,k) * manip.jointvar.qd(k);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
disp (<span class="string">'  C'</span>);

<span class="comment">% -g</span>
<span class="keyword">for</span> i=1:r
    <span class="keyword">for</span> j=1:r
        g(i) = g(i) + ml(j) * g0.' * Jp_l{j}(:,i)  + mm(j) * g0.' * Jp_m{j}(:,i);
    <span class="keyword">end</span>
<span class="keyword">end</span>
disp (<span class="string">'  g'</span>);

disp (<span class="string">' simplifying expressions'</span>);
manip.dyn.B = simple_(B);
disp (<span class="string">'  B simplified'</span>);
manip.dyn.C = simple_(C);
disp (<span class="string">'  C simplified'</span>);
manip.dyn.g = simple_(-g);
disp (<span class="string">'  g simplified'</span>);

<span class="comment">% symbolic data robot:</span>
<span class="comment">% future versions should calculate Y matrix, piv vector</span>
<span class="keyword">if</span> manip.is_sym || (isa(manip.dyn.data.Il,<span class="string">'sym'</span>) || <span class="keyword">...</span>
        isa(manip.dyn.data.Im ,<span class="string">'sym'</span>) || <span class="keyword">...</span>
        isa(manip.dyn.data.ml ,<span class="string">'sym'</span>) || <span class="keyword">...</span>
        isa(manip.dyn.data.mm ,<span class="string">'sym'</span>) || <span class="keyword">...</span>
        isa(manip.dyn.data.pl ,<span class="string">'sym'</span>) || <span class="keyword">...</span>
        isa(manip.dyn.data.pm ,<span class="string">'sym'</span>))
    disp(<span class="string">'symbolic data robot, no function files generated'</span>);
<span class="keyword">else</span>

    <span class="comment">% numeric data robot</span>
    <span class="comment">% generate functions for simulation</span>
    disp(<span class="string">'numeric data robot: generating function files ...'</span>);

<span class="comment">%     disp ('  calculating inv(B)');</span>
<span class="comment">%     invB = inv(B);</span>
<span class="comment">%</span>
<span class="comment">%     disp ('  simplifying inv(B)');</span>
<span class="comment">%     invB = simple_(invB);</span>
<span class="comment">%     manip.dyn.invB = invB;</span>


    <span class="comment">% generate symbolic variables tau_1 .. tau_r</span>
<span class="comment">%     tau = cell(1,r);</span>
<span class="comment">%     for i=1:1:r</span>
<span class="comment">%         i_str = num2str(i);</span>
<span class="comment">%         eval(['syms tau_', i_str, ';']);</span>
<span class="comment">%         eval(['tau{i} = tau_', i_str, ';']);</span>
<span class="comment">%     end</span>
<span class="comment">%     tau_v = horzcat(tau{:});</span>

    <span class="comment">% write function file</span>
<span class="comment">%     sym_mat2func(manip.dyn.invB , tau_v, manip.jointvar.q ,...</span>
<span class="comment">%         [manip.name,'_invB_tau'],30);</span>
<span class="comment">%     eval(['manip.func.invB_tau = @', manip.name, '_invB_tau;']);</span>

    sym_mat2func(manip.dyn.B(:) , [], manip.jointvar.q ,<span class="keyword">...</span>
        [manip.name,<span class="string">'_B_matrix'</span>],30);
    eval([<span class="string">'manip.func.B_matrix = @'</span>, manip.name, <span class="string">'_B_matrix;'</span>]);


    sym_mat2func(manip.dyn.B , manip.jointvar.qdd, manip.jointvar.q ,<span class="keyword">...</span>
        [manip.name,<span class="string">'_B_qdd'</span>],30);
    eval([<span class="string">'manip.func.B_qdd = @'</span>, manip.name, <span class="string">'_B_qdd;'</span>]);


    sym_mat2func(manip.dyn.C , manip.jointvar.qd, <span class="keyword">...</span>
        [manip.jointvar.q manip.jointvar.qd] ,[manip.name,<span class="string">'_C_qd'</span>],30);
    sym_mat2func(manip.dyn.g, [] , [manip.jointvar.q] ,[manip.name,<span class="string">'_g'</span>],30);

    eval([<span class="string">'manip.func.C_qd = @'</span>, manip.name, <span class="string">'_C_qd;'</span>]);
    eval([<span class="string">'manip.func.g = @'</span>, manip.name, <span class="string">'_g;'</span>]);
    disp (<span class="string">'  functions created. '</span>);
    disp (<span class="string">'  Execution Completed. '</span>);
<span class="keyword">end</span>

manip.evaluated.Direct_Dynamics = 1;
assignin(<span class="string">'caller'</span>,inputname(1),manip);

<span class="keyword">return</span>
</pre><p class="footer"><br>
            Published with MATLAB&reg; 7.4<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
function Direct_Dynamics(manip)

% DIRECT_DYNAMICS evaluates direct dynamics of a manipulator object
%    syntax: manip.Direct_Dynamics
%
%  Evaluates: dynamic matrices B C g
%             Jacobian matrices related to rotors' and joints' COM position
%             and stores them into manipulator as follows:
%
%     manip
%       |
%       +REPLACE_WITH_DASH_DASHdyn
%       |   +REPLACE_WITH_DASH_DASHB: manipulator inertia matrix
%       |   +REPLACE_WITH_DASH_DASHC: Coriolis and centripetal matrix (christoffeln)
%       |   +REPLACE_WITH_DASH_DASHg: gravity coloumn vector
%       |
%       +REPLACE_WITH_DASH_DASHkin
%       |   +REPLACE_WITH_DASH_DASH Jp_l{1}..Jp_l{n}: geometric Jacobian matrix related to joints' COM position
%       |   +REPLACE_WITH_DASH_DASH Jo_l{1}..Jo_l{n}: geometric Jacobian matrix related to joints' COM orientation
%       |   +REPLACE_WITH_DASH_DASH Jp_m{1}..Jp_m{n}: geometric Jacobian matrix related to rotors' COM position
%       |   +REPLACE_WITH_DASH_DASH Jo_m{1}..Jo_m{n}: geometric Jacobian matrix related to rotors' COM orientation
%
%
%    needs:
%       * direct kinematics evaluation through Direct_Kinematics.
%       * a correct set of dynamic data (masses, inertia tensors ...)
%         inserted through InsertDyndata,
%
%    note : COM stands for 'center of mass'
% 
%     See also manipulator
%              manipulator/InsertDyndata
%              manipulator/Direct_Kinematics
%
% Copyright (C) 2009, by Carmine Dario Bellicoso and Marco Caputano.
% This file is part of GNU LGPLv2.1 DAMA^{ROB}
%    http://www.damarob.altervista.org
%

%% check data
if isempty(manip.dyndata) || manip.dyndata ~= 1
    NL = [char(13),char(10)]; % 'new line' string
    disp(['Dynamic Data not inserted correctly, see manipulator.dyndata ',NL,'Direct_Dynamics aborted.',NL]);
    return
end

if manip.DH.r == 0
    manip.display;
    return
end

if manip.evaluated.Direct_Dynamics == 1
    NL = [char(13),char(10)]; % 'new line' string
    disp(['Direct Dynamics already evaluated ',NL,'Direct_Dynamics aborted.',NL]);
    return
end

if manip.evaluated.Direct_Kinematics == 0
    NL = [char(13),char(10)]; % 'new line' string
    disp(['Direct Kinematics not evaluated ',NL,'Please run Direct_Kinematics first.',NL]);
    return    
end


%% Some initializations
g0 = manip.dyn.data.g0(:);
r = manip.DH.r;
DH = cell(1,r);
Jp_l = cell(1,r);
Jo_l = cell(1,r);
Jp_m = cell(1,r);
A = cell(1,r);
R = cell(1,r);
Rm = cell(1,r);
B = sym(zeros(r,r));
C = sym(zeros(r,r));
chr = sym(zeros(r,r,r));
g = sym(zeros(r,1));
% T = cell(1,r);

pl = manip.dyn.data.pl;
pm = manip.dyn.data.pm;
kr = manip.dyn.data.kr;
ml = manip.dyn.data.ml;
mm = manip.dyn.data.mm;
I_l = manip.dyn.data.Il;
I_m = manip.dyn.data.Im;
zm = manip.dyn.data.zm;

% coloumn vectors
for i=1:r
    pl{i} =  pl{i}(:);
    pm{i} =  pm{i}(:);
    zm{i} =  zm{i}(:);
end

% store manipulator's data into cell arrays
for i=1:r
    R{i} = manip.kin.R.R{i}; %R{i} = R_i
    %    T{i} = manip.kin.T.T{i}; %T{i} = T_i
    A{i} = manip.kin.A.A{i}; %A{i} = A_i
    % note that A_i is the homogeneous transformation matrix between frames i and i-i
end

%% Jacobian matrices of center of masses
disp('Evaluating jacobian matrices of center of masses ...');
for i=1:r
    DH{i} = manip.DH.table(1:i , :);    %firsts 'i' rows of DH table
    if DH{i}(i,5) == 0 % revolute joint
        DH{i}(i,1) = DH{i}(i,1) + [1 0 0]*pl{i};  % adds pl_i|x to a(i)
    else               % prismatic joint
        DH{i}(i,3) = [0 0 1 0] * A{i}*[pl{i};1];  %adds (l_i^(i-1))_z to d(i)
    end

    robtemp = manipulator([DH{i}(:,1),DH{i}(:,2),DH{i}(:,3),DH{i}(:,4),DH{i}(:,5)],'tmp');
    robtemp.Direct_Kinematics;

    Jli = [robtemp.kin.J.J zeros(6,r-i)];
    Jp_l{i} = Jli(1:3,:);
    Jo_l{i} = Jli(4:6,:);
    robtemp.delete;
end


% (store)
manip.kin.J.Jp_l=Jp_l;
manip.kin.J.Jo_l=Jo_l;

%% Jacobian matrices of motors

disp('Evaluating jacobian matrices of motors ...');
% Orientation
Jo_m = Jo_l;
for i=1:r
    Jo_m{i}(:,i) = kr(i)*zm{i};
end

Jp_m{1} = 0*Jp_l{1}; % init
% Position
for i=1:r-1
    DH{i} = manip.DH.table(1:i , :);    %firsts 'i' rows of DH table
    if DH{i}(i,5) == 0 % revolute joint
        DH{i}(i,1) = DH{i}(i,1) + [1 0 0]*pm{i+1};  % adds pm_(i+1)|x to a(i)
    else               % prismatic joint
        %adds (pm_(i+1)^(i-1))_z to d(i)
        DH{i}(i,3) = [0 0 1 0] * A{i}*[pm{i+1};0];
    end

    %     robtemp = Denavit_Hartenberg_Table(DH{i}(:,1).', ...
    %         DH{i}(:,2).',DH{i}(:,3).',DH{i}(:,4).',DH{i}(:,5).');
    %     robtemp = Direct_Kinematics(robtemp);
    robtemp = manipulator([DH{i}(:,1),DH{i}(:,2),DH{i}(:,3),DH{i}(:,4),DH{i}(:,5)],'tmp');
    robtemp.Direct_Kinematics;

    Jmip1 = [robtemp.kin.J.J zeros(6,r-i)];
    Jp_m{i+1} = Jmip1(1:3,:);
    robtemp.delete;
end


% (store)
manip.kin.J.Jp_m=Jp_m;
manip.kin.J.Jo_m=Jo_m;

%% Rotor's rotation matrices

disp('Evaluating rotor''s rotation matrices ...');
%   Rm matrices will be:
% [ 0 0  | ]
% [ 0 0 zm ]
% [ 0 0  | ]
% where first two columns will be two vectors orthonormal to zm

for i=1:r
    zmi = R{i}*zm{i} / norm(zm{i});      % zmi in 0-frame, normalized
    ymi = cross(zmi,rand(3,1));  % pseudorandom vector, perpendicular to zm
    norm_ymi = (ymi.'*ymi)^(1/2);
    ymi = ymi/norm_ymi;                        % ymi orthonormal to zm
    xmi = cross(ymi,zmi);                        % xmi
    Rm{i} = [xmi, ymi, zmi];
end

%% Dynamics Matrices

disp('Evaluating dynamics matrices ...');
% B
for i=1:r
    B = B + ml(i) * (Jp_l{i}.' * Jp_l{i}) + ...
        (Jo_l{i}.' *R{i} *I_l{i} *R{i}.'  * Jo_l{i}) + ...
        mm(i) * Jp_m{i}.' * Jp_m{i} + ...
        (Jo_m{i}.' *Rm{i} *I_m{i} *Rm{i}.'  * Jo_m{i}) ;
end
disp ('  B');

% christoffel's signs (C)
for i=1:r
    for j=1:r
        for k=1:r
            chr(i,j,k) = 1/2* ( diff(B(i,j), manip.jointvar.q(k)) + ...
                diff(B(i,k), manip.jointvar.q(j)) - ...
                diff(B(j,k), manip.jointvar.q(i)));
        end
    end
end

% C
for i=1:r
    for j=1:r
        for k=1:r
            C(i,j) = C(i,j) + chr(i,j,k) * manip.jointvar.qd(k);
        end
    end
end
disp ('  C');

% -g
for i=1:r
    for j=1:r
        g(i) = g(i) + ml(j) * g0.' * Jp_l{j}(:,i)  + mm(j) * g0.' * Jp_m{j}(:,i);
    end
end
disp ('  g');

disp (' simplifying expressions');
manip.dyn.B = simple_(B);
disp ('  B simplified');
manip.dyn.C = simple_(C);
disp ('  C simplified');
manip.dyn.g = simple_(-g);
disp ('  g simplified');

% symbolic data robot:
% future versions should calculate Y matrix, piv vector
if manip.is_sym || (isa(manip.dyn.data.Il,'sym') || ...
        isa(manip.dyn.data.Im ,'sym') || ...
        isa(manip.dyn.data.ml ,'sym') || ...
        isa(manip.dyn.data.mm ,'sym') || ...
        isa(manip.dyn.data.pl ,'sym') || ...
        isa(manip.dyn.data.pm ,'sym'))
    disp('symbolic data robot, no function files generated');
else

    % numeric data robot
    % generate functions for simulation
    disp('numeric data robot: generating function files ...');

%     disp ('  calculating inv(B)');
%     invB = inv(B);
% 
%     disp ('  simplifying inv(B)');
%     invB = simple_(invB);
%     manip.dyn.invB = invB;


    % generate symbolic variables tau_1 .. tau_r
%     tau = cell(1,r);
%     for i=1:1:r
%         i_str = num2str(i);
%         eval(['syms tau_', i_str, ';']);
%         eval(['tau{i} = tau_', i_str, ';']);
%     end
%     tau_v = horzcat(tau{:});

    % write function file
%     sym_mat2func(manip.dyn.invB , tau_v, manip.jointvar.q ,...
%         [manip.name,'_invB_tau'],30);
%     eval(['manip.func.invB_tau = @', manip.name, '_invB_tau;']);

    sym_mat2func(manip.dyn.B(:) , [], manip.jointvar.q ,...
        [manip.name,'_B_matrix'],30);
    eval(['manip.func.B_matrix = @', manip.name, '_B_matrix;']);


    sym_mat2func(manip.dyn.B , manip.jointvar.qdd, manip.jointvar.q ,...
        [manip.name,'_B_qdd'],30);
    eval(['manip.func.B_qdd = @', manip.name, '_B_qdd;']);


    sym_mat2func(manip.dyn.C , manip.jointvar.qd, ...
        [manip.jointvar.q manip.jointvar.qd] ,[manip.name,'_C_qd'],30);
    sym_mat2func(manip.dyn.g, [] , [manip.jointvar.q] ,[manip.name,'_g'],30);

    eval(['manip.func.C_qd = @', manip.name, '_C_qd;']);
    eval(['manip.func.g = @', manip.name, '_g;']);
    disp ('  functions created. ');
    disp ('  Execution Completed. ');
end

manip.evaluated.Direct_Dynamics = 1;
assignin('caller',inputname(1),manip);

return

##### SOURCE END #####
-->
   </body>
</html>